<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>viz test</title>
        <!--<link rel="stylesheet" href="tut.css">-->
        <script type="text/javascript" src="d3/d3.v3.js"></script>
    </head>

    <body>
        <p> click to toggle between school-only and all </p>
        <script type="text/javascript">
          
            var width = 1500,
                height = 1300;

            var colors = d3.scale.category10();

            var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // svg elements to hold links and nodes respectively
            // the link group is appended first so that the visual circle elements will cover the line elements
            // that way the edges connect to the outside of the nodes rather than the centre
            var linkGroup = svg.append("g").attr("id", "link_display");
            var nodeGroup = svg.append("g").attr("id", "node_display");

            var force = d3.layout.force()
                .gravity(.05)
                //.distance(200)
                .linkDistance([175])
                .charge(-150)
                .size([width, height]);

            var just_school = true;

  
            d3.json("csgraph.json", function(error, graph)  {
              
              //var all_data = graph

              // for d3 force layout to work, the links can reference the actual source and target node objects
              // or they can reference the index of the objects in the nodes array
              // networkx's json string uses the index referencing
              // however if we want to add or remove nodes from the array (to filter the data that we want to
              // see), the index referencing will not work, as nodes will not be in the positions referenced by the links
              // so here we replace the references to indices with the references to the objects themselves
              for(var i=0; i < graph.links.length; i++) {
                graph.links[i].source = graph.nodes[graph.links[i].source];
                graph.links[i].target = graph.nodes[graph.links[i].target];
              }

              var allLinks = graph.links
              var allNodes = graph.nodes

              var link
              var node

              // NB this is the JS array filter() not the d3 filter being used here
              // This gets just the links whose nodes both represent authors belonging to the school being displayed
              var filteredLinks = graph.links.filter(function(l) {
                good = l.source.in_school && l.target.in_school;
                if(good)
                  console.log("ok", l);
                return good;
              })
              // This gets just the nodes that represent authors belonging to the school being displayed
              var filteredNodes = graph.nodes.filter(function(n) {
                return n.in_school;
              });


              for(var i=0; i<allLinks.length; i++) {
                if(allLinks[i].source.id == "Calder, Professor Muffy" || allLinks[i].target.id == "Calder, Professor Muffy") 
                    console.log(allLinks[i].source.id + ", " + allLinks[i].target.id)
              }

              // Create a map indicating whether 2 nodes are adjacent, to make it faster to check this when necessary
              // idea from Mike Bostock - http://stackoverflow.com/a/8780277
              var neighboursMap = {}
              for(var i=0; i < allLinks.length; i++) {
                neighboursMap[allLinks[i].source.id + "," + allLinks[i].target.id] = 1;
                neighboursMap[allLinks[i].target.id + "," + allLinks[i].source.id] = 1;
              }

              // Add the node and link data to the layout and start the simulation
              function startForce(nodes, links) {
                force.nodes(nodes)
                      .links(links)
                      .start();  
              }

              // Used to bind new link data to visual elements and display
              function updateLinks(links) {
                link = linkGroup.selectAll(".link")
                      .data(links)   
                      
                link.enter()
                      .append("line")
                      .attr("class", "link")
                      .style("stroke", "black")
                      .style("stroke-width", 1);

                console.log("PRINTING NEW links")
                for(var i=0; i<link.enter().length; i++) {
                  console.log(link.enter()[i])
                }

                link.exit().remove()

                //link = svg.selectAll(".link")
              }

              // Used to bind new node data to visual elements and display
              function updateNodes(nodes) {
                node = nodeGroup.selectAll(".node")
                    /* second argument to data() is a d3 "key function", used to join data to visual elements by the return value (a unique string,
                     in this case the id)
                     The default behaviour is joining by index - data is joined to elements in order. That wouldn't work here because we are using
                     2 different sets of data (all the nodes and just the filtered nodes), so we need to associate elements to datums by their id.
                     Example problem - we have an initial nodeset [a, b, c, d, e] they will be linked to node elements by index like so:
                     a --> 0
                     b --> 1
                     c --> 2
                     d --> 3
                     e --> 4
                     Then we filter the dataset to [b, d, e]
                     b --> 0
                     d --> 1
                     e --> 2
                     Because the new dataset is size 3, elements (0, 1, 2), previously linked to other data, remain, the others are discarded
                     But the elements will still be displaying the names of nodes [a, b, c]
                     If we associate data to elements by a key, then when [b, d, e] come in they will remain linked to their original elements:
                     b --> 1
                     d --> 3
                     e --> 4  
                    */
                    .data(nodes, function(d) {
                      return d.id;
                    })

                // New nodes - we get these the first time the page is loaded and when we go from displaying filtered nodes to all nodes
                nodeG = node.enter()
                    .append("g")
                    .attr("class", "node")
                    .call(force.drag);

                  nodeG.append("circle")
                    .attr("r", 10)
                    .style("fill", function(d, i) {
                        return colors(i);
                    });

                  nodeG.append("text")
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .text(function(d) { 
                      console.log("new node, id is " + d.id)
                      return d.id })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle");

                    // Remove the elements that no longer have data attached - i.e. the nodes that aren't in filtered nodes
                    node.exit().remove();

                    // attach event listeners here so they get attached to new nodes as well
                    node.on("mouseover", highlight)
                    node.on("mouseout", lowlight)
              }

              var highlight = function(d) {
                //alert("hey");
                link.style("stroke", function(l) {
                  if (l.source == d || l.target == d)
                    return "red";
                  else
                    return "black";
                })
                .style("opacity", function(l) {
                  if (l.source == d || l.target == d)
                    return 1.0
                  else
                    return 0.1
                });

                node.style("opacity", function(o) {
                  if (neighbours(d, o))
                    return 1.0
                  else
                    return 0.1
                });
                d3.select(this).style("opacity", 1.0);
              }

              var lowlight = function(d) {
                link.style("stroke", "black")
                .style("opacity", 1.0);

                node.style("opacity", 1.0);
              }


              function neighbours(n1, n2) {
                return neighboursMap[n1.id + "," + n2.id]
              }


              startForce(filteredNodes, filteredLinks);
              updateLinks(filteredLinks);
              updateNodes(filteredNodes); 

              // force simulation is running in background, position of things is changing with each tick
              // In order to see this visually, we need to get the current x and y positions on each tick and update the lines 
              force.on("tick", function() {
               link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
                // same with g elements, but these have no x and y, have to be translated
                node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
              });  


              d3.select("p").on("click", function() {                
                if(just_school) {
                  startForce(allNodes, allLinks);
                  updateLinks(allLinks);
                  updateNodes(allNodes);

                  just_school = false;
                }
                else {
                  startForce(filteredNodes, filteredLinks);
                  updateLinks(filteredLinks);
                  updateNodes(filteredNodes);

                  just_school = true;
                }
              });

           });

        </script>
    </body>
</html>   