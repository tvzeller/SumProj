<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>viz test</title>
        <!--<link rel="stylesheet" href="tut.css">-->
        <script type="text/javascript" src="d3/d3.v3.js"></script>
    </head>

    <body>
        <p id="tog"> click to toggle between school-only and all </p>
        <script type="text/javascript">
          
            var width = 1500,
                height = 1300;

            var colors = d3.scale.category10();

            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

            var force = d3.layout.force()
                .gravity(.05)
                //.distance(200)
                .linkDistance([175])
                .charge(-150)
                .size([width, height]);

            var just_school = true;


            d3.json("csgraph.json", function(error, graph) {
              
              //var all_data = graph

              // for d3 force layout to work, the links can reference the actual source and target node objects
              // or they can reference the index of the objects in the nodes array
              // networkx's json string uses the index referencing
              // however if we want to add or remove nodes from the array (to filter the data that we want to
              // see), the index referencing will not work, as nodes will not be in the positions referenced by the links
              // so here we replace the references to indices with the references to the objects themselves
              for(var i=0; i < graph.links.length; i++) {
                graph.links[i].source = graph.nodes[graph.links[i].source];
                graph.links[i].target = graph.nodes[graph.links[i].target];
              }
              console.log("printing graph.links")
              console.log(graph.links)

              var displayedLink;
              var displayedNode;

              var allLinks = graph.links
              var allNodes = graph.nodes

              // NB this is the JS array filter() not the d3 filter being used here
              // This gets just the links whose nodes both represent authors belonging to the school being displayed
              var filteredLinks = graph.links.filter(function(l) {
                good = l.source.in_school && l.target.in_school;
                if(good)
                  console.log("ok", l);
                return good;
              });
              // This gets just the nodes that represent authors belonging to the school being displayed
              var filteredNodes = graph.nodes.filter(function(n) {
                return n.in_school;
              });


              function startForce(nodes, links) {
                force.nodes(nodes)
                      .links(links)
                      .start();  
              }

              function updateLinks(links) {
                var linkClass = svg.selectAll(".link")
                    .data(links)
                  
                var newLinks = linkClass.enter()
                      .append("line")
                    //TODO this is a test
                  /*  .filter(function(l) {
                    keep = l.source.in_school && l.target.in_school
                    if(keep)
                      console.log("kepto", l)
                    else
                      console.log("nota", l)
                    return keep
                  })*/
                    .attr("class", "link")
                    .style("stroke", "black")
                    .style("stroke-width", 1);

                linkClass.exit().remove();

                displayedLink = svg.selectAll(".link")
              }

              function updateNodes(nodes) {
                var nodeClass = svg.selectAll(".node")
                    .data(nodes)

                var newNodes = nodeClass.enter()
                        .append("g")
                 /*   .filter(function(d) {
                      return d.in_school;
                    })*/
                      .attr("class", "node")
                      .call(force.drag);

                    newNodes.append("circle")
                      .attr("r", 10)
                      .style("fill", function(d, i) {
                          return colors(i);
                      });

                  newNodes.append("text")
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .text(function(d) { return d.id })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle");

                nodeClass.exit().remove();
                // Not sure if necessary to do selection again but seems to break if not
                displayedNode = svg.selectAll(".node");   
              }


              function highlightAuthor(authorId) {

              }


              startForce(filteredNodes, filteredLinks);
              updateLinks(filteredLinks);
              updateNodes(filteredNodes)


              // force simulation is running in background, position of things is changing with each tick
              // In order to see this visually, we need to get the current x and y positions on each tick and update the lines 
              force.on("tick", function() {
                displayedLink.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
                // same with g elements, but these have no x and y, have to be translated
                displayedNode.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
              });  


              d3.select("p").on("click", function() {
                alert("hello node");
                
                if(just_school) {
                  startForce(allNodes, allLinks);
                  updateLinks(allLinks);
                  updateNodes(allNodes);

                  just_school = false;
                }
                else {
                  startForce(filteredNodes, filteredLinks);
                  updateLinks(filteredLinks);
                  updateNodes(filteredNodes);

                  just_school = true;
                }
              });

              displayedNode.on("mouseover", function(n) {
                //alert(n.id);
                displayedLink.style("stroke", function(l) {
                  if (l.source == n || l.target == n)
                    return "red";
                  else
                    return "black";
                })
                
                .style("opacity", function(l) {
                  if (l.source == n || l.target == n)
                    return 1.0
                  else
                    return 0.5
                });

                displayedNode.style("opacity", 0.5);
                d3.select(this).style("opacity", 1.0);
              });


              displayedNode.on("mouseout", function(n) {
                displayedLink.style("stroke", "black")
                .style("opacity", 1.0);
                
                displayedNode.style("opacity", 1.0);
              });

           });

        </script>
    </body>
</html>   